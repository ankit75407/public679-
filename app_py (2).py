# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1745JM0dmTANxCtPFNKZtIKBbi6i_nGvb
"""



# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import pandas_datareader as data
plt.style.use('fivethirtyeight')
# %matplotlib inline

import yfinance as yf
import datetime as dt

stock = "POWERGRID.NS","AAPL","NVDA", "MSFT", "GOOG", "AMZN",  "2222.SR", "META", "META", "TSM", "LLY", "AVGO", "TSLA", "NVO", "WMT", "UNH", "XOM", "V", "JPM", "JNJ", "MA",

start = dt.datetime(2000,1,1)
end = dt.datetime.now()
df = yf.download(stock, start, end)

df.head()

df.shape

df.info()

df.isnull().sum()

df.describe()

df = df.reset_index()

df.shape

df.head()

df.columns

data01 = df.to_csv('stock.csv')

data01 = pd.read_csv('stock.csv')
data01.head()



# candlesticks
import plotly.graph_objects as go

# When saving to csv, set index=False to include the index as a column named 'Date'
# data01 = df.to_csv('stock.csv', index=False)  # Previous incorrect line
# OR, load the data making sure to use the first column as index
data01 = pd.read_csv('stock.csv', index_col=0) # Suggested fix

fig = go.Figure(data=[go.Candlestick(x=data01.index,
                open=data01['Open'],
                high=data01['High'],
                low=data01['Low'],
                close=data01['Close'])])

fig.show()

df.head()

plt.figure(figsize=(50,40))
plt.plot(df['Close'], label='Closing price', linewidth=1)
plt.title(f'{stock} closing prices over time')
plt.legend()
plt.show()

plt.figure(figsize=(50,40))
plt.plot(df['High'], label='High price', linewidth=1)
plt.title(f'{stock} High prices over time')
plt.legend()
plt.show()

plt.figure(figsize=(30,6))
plt.plot(df['Volume'], label='Volume price', linewidth=1)  # Changed 'volume' to 'Volume'
plt.title(f'{stock} Volume prices over time')
plt.legend()
plt.show()

"""# New Section

# New Section
"""

temp_data = [10,20,30,40,50,60,70,80,90,]
print(sum(temp_data[2:7])/5)

import pandas as pd
df01 = pd.DataFrame(temp_data)

df01.rolling(5).mean()

ma100 = df01[0].rolling(100).mean() # Access the first column using its index (0)

ma100

ma200 = df['Close'].rolling(200).mean()  # Access the 'Close' column using brackets

plt.figure(figsize=(12, 6))
plt.plot(df.Close, label = f'{stock} Close Price', linewidth = 1)
# Calculate and plot the Exponential Moving Average (EMA) instead of using the undefined 'ema100' and 'ema200'
ema100 = df['Close'].ewm(span=100, adjust=False).mean()  # Calculate EMA with span 100
ema200 = df['Close'].ewm(span=200, adjust=False).mean()  # Calculate EMA with span 200
plt.plot(ema100, label = f'{stock} Exp. Moving Average 100 Price', linewidth = 1)
plt.plot(ema200, label = f'{stock} Exp. Moving Average 200 Price', linewidth = 1)
plt.legend()
plt.show()

data_training = pd.DataFrame(df['Close'][0:int(len(df)*0.70)])
data_testing = pd.DataFrame(df['Close'][int(len(df)*0.70): int(len(df))])

data_training.shape

data_testing.shape

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler(feature_range = (0, 1))

data_training_array = scaler.fit_transform(data_training)

data_training_array

data_training_array.shape[0]

x_train = []
y_train = []

for i in range(100, data_training_array.shape[0]):
    x_train.append(data_training_array[i-100:i])
    y_train.append(data_training_array[i, 0])

x_train, y_train  = np.array(x_train), np.array(y_train)

x_train.shape

from keras.layers import Dense, Dropout, LSTM
from keras.models import Sequential

model = Sequential()

model.add(LSTM(units = 50, activation = 'relu', return_sequences = True, input_shape = (x_train.shape[1],1)))
model.add(Dropout(0.2))

model.add(LSTM(units = 60, activation = 'relu', return_sequences = True))
model.add(Dropout(0.3))

model.add(LSTM(units = 80, activation = 'relu', return_sequences = True))
model.add(Dropout(0.4))

model.add(LSTM(units = 120, activation = 'relu'))
model.add(Dropout(0.5))

model.add(Dense(units = 1))

model.summary()

model = Sequential()

# Reshape x_train to have the correct number of features
num_features = x_train.shape[2]  # Get the actual number of features from x_train
# Assuming x_train.shape is (num_samples, num_timesteps, num_features)

# Update the input shape for the first LSTM layer
model.add(LSTM(units=50, activation='relu', return_sequences=True,
               input_shape=(x_train.shape[1], num_features)))  # Use num

past_100_days = data_training.tail(100)

final_df = pd.concat([past_100_days, data_testing], ignore_index=True)

final_df.head()

input_data = scaler.fit_transform(final_df)

x_test = []
y_test = []

for i in range(100, input_data.shape[0]):
    x_test.append(input_data[i-100:i])
    y_test.append(input_data[i, 0])

x_test, y_test  = np.array(x_test), np.array(y_test)

x_test.shape

# ... (previous code)

# Predict values using the model:
y_predicted = model.predict(x_test)

# Now, access the shape:
y_predicted.shape

scaler.scale_

scaler_factor = 1 / 0.0035166
y_predicted = y_predicted * scaler_factor
y_test = y_test * scaler_factor

plt.figure(figsize=(12, 6))
plt.plot(y_test, label = 'Original Price', linewidth = 1)
# Assuming y_predicted is 3D, we take the first element from the last two dimensions:
plt.plot(y_predicted[:, 0, 0], label = 'Predicted Price', linewidth = 1)
plt.legend()
plt.show()

model.save('stock_dl_model.h5')